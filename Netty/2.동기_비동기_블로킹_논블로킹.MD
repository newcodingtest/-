### 동기(Synchronous) , 비동기(Asynchronous)

**작업을 실행하는 여러개의 함수들이 '시간을 맞춰서 실행되느냐'에 따라 구분**



#### 동기

함수들이 작업을 동시에 시작하거나, 끝나는 타이밍을 맞추거나, 하나가 끝나고 다른 하나를 차례로 실행하는 것

![image](https://user-images.githubusercontent.com/57785267/163554542-6f660055-02ed-4954-a2fd-31c095b7f054.png)

```
요청자가 요청한 일들이 완료되었는지를 계속 확인하기 때문이다. 요청하는 함수는 요청을 보내놓고, 요청을 처리하는 함수들이 작업을 마쳤는지 계속해서 물어본다. 요청자는 완료가 되었다는 응답을 받으면, 그때 다른 함수의 실행을 시작하거나 하는 것이다.
```

**또 다른 관점**에서는  **제어권과 결과값을 동시에 반환하는 것**

![image](https://user-images.githubusercontent.com/57785267/163554563-f178270e-1536-4411-8fad-9cd5e0b9f7d1.png)



#### 비동기

두 함수는 서로가 언제 시작하고, 언제 일을 마치는지 전혀 신경쓰지 않는 것(개인플레이)

![image](https://user-images.githubusercontent.com/57785267/163554583-80dd59b4-b010-41f0-bcdc-d5a5f5af01c0.png)

```
요청을 받은 함수가 완료되었는지 여부를 알아서 알려주는 방식이다. 이렇게 작업을 시작하고 끝내는 시간을 아는 것은 호출된 함수 본인뿐이기 때문에, 여러 함수들이 시작되고 끝나는 시간은 맞춰지지 않을 수 있게 된다. 혹은 결과값과 제어권이 다른 시점에 따로따로 반환되는 것도 비동기
```



### 블로킹과 논블로킹

**요청받은 함수가 제어권을 언제 돌려주는지?**



**\- 블로킹 :** 함수관점에서는 함수를 호출할 때, 제어권도 아예 함께 넘겨주고 작업이 끝난 후에 돌려받는 방식

```
요청한 작업이 성공하거나 에러가 발생하기 전까지 응답을 돌려주지 않음
```

**\- 논블로킹 :** 함수관점에서는 호출할 때 제어권을 넘겨주기는 하지만, 바로 돌려받는다. A의 작업이 안끝나도 바로 제어권을 돌려받고 부모함수는 B작업을 시작하는 것이다.

```
요청한 작업의 성공 여부와 상관없이 바로 결과를 돌려줌. 이때 요청의 응답값에 의해서 에러나 성공여부 판단
```



**블로킹 소켓:** ServerSocket, Socket

**논블로킹 소켓:** ServerSocketChannel, SocketChannel



#### **블로킹 소켓의 동작 방식**

![img](https://user-images.githubusercontent.com/41428527/51266321-4ade9700-19fe-11e9-9b23-30bca4faccfd.png)



![image](https://user-images.githubusercontent.com/57785267/163554656-b985f6b4-f013-4376-8b8c-b8ef310e9001.png)



블로킹 소켓은 입출력에서 스레드의 블로킹이 발생, 때문에 동시에 여러 클라이언트에 대한 처리가 불가능



블로킹 소켓 서버의 다중 클라이언트 접속처리를 해결하기 위해 **연결당 스레드 생성 모델** 등장





####  **연결당 스레드 생성 모델**

![image](https://user-images.githubusercontent.com/57785267/163554637-d8165d4e-c7f0-4db3-99a0-c9de397a4840.png)

블로킹 소켓은 I/P 처리에 블로킹이 발생하기 때문에 새로운 스레드를 하나 생성하고 그 스레드에게 클라이언트 소켓에 대한 I/O처리를 넘겨준다.

이 방식 또한**서버 소켓의 accept 메서드에서 병목이 발생한다**

```
여러 클라이언트에서 동시접속을 요청하는 경우, 접속할 클라이언트 수가 정해져 있지 않은경우, OOM(Out Of Memory)문제 발생
```





#### 스레드 풀링 모델

![Single-Thread Server VS Multi-Thread Server | by Sun-do Kim | POCS | Medium](https://miro.medium.com/max/1190/1*4-0ldZUITUKQqKv1XxhgPQ.png)



동시 접속 가능한 사용자 수가 스레드 풀에 지정된 스레드 수에 의존

**스레드 풀을 자바 힙이 허용하는 최대 한도에 도달할때까지 늘리면?**

 -> 이때 자바 프로세스는 가비지 컬렉션을 완료하기 위해서 다른 스레드를 멈춤

  -> 애플리케이션이 먹통된것 처럼 보임

  -> 힙 크기가 크면 클수록 가비지 컬렉션에 드는 시간이 길어짐

\- 힙에 할당된 메모리가 크면 클수록 가비지 컬렉션이 수행되는 횟수는 줄지만, 수행시간은 상대적으로 길어짐





#### 정리

블로킹 소켓 동작 방식으로 인하여 블로킹 소켓을 사용한 서버는 충분히 많은 동시접속 사용자를 수용하지 못함

이의 단점을 보완한것이 **논블로킹 소켓 방식**이다.





### 논블로킹 소켓

![image](https://user-images.githubusercontent.com/57785267/163554769-88a91ca9-0992-4d8d-a7d0-f6a3e0061f86.png)

1.클라이언트(Application)이 서버(Kernel)에게 read를 요청을 하면

2.데이터가 없으면 없다는 결과메시지(EWOULDBLOCK)를 반환한다.

3.데이터가 있을때까지 1-2 를 반복한다.

4.데이터가 있으면 유저에게 결과가 전달된다.



해당 과정의 경우 오랜시간 중지하지 않고 I/O 작업을 진행할 수 있다.

그러나 반복적인 시스템 호출로 인해 자원이 낭비된다.



그러나 이 방식은 서버가 클라이언트에게 요청이 올때까지 또는 클라이언트가 서버에게 요청이 올때까지 대기를 하기 때문에 

EX)

카카오톡에서 상대방에게 보낸 메세지가 있는지 물어보는방식(**논블로킹 방식**)

사용자가 보낸 메시지가 있습니다 라고 알려주는 방식**(I/O 이벤트 통지 방식**)

이문제를 해결하기 위한 **I/O 이벤트 통지 모델**을 알아보자





### I/O 이벤트 통지 모델

 **Non-Blocking**에서 제기된 문제를 해결하기 위해 **I/O 이벤트 통지 모델**이 도입되었다

이건 또 2가지로 나뉜다.

**1.동기방식**

```
I/O 작업이 진행되는 동안 요청한 프로세스는 결과를 기다렸다가 이벤트(결과)를 직접 처리
```

기다리는 방식은

bloking 방식처럼 요청하고 결과값을 받을때까지 기다릴수 있고, non-blocking 처럼 계속 요청하는 방식으로 할 수도 있다.

**2.비동기방식**

```
I/O 작업이 진행되는 동안 요청한 프로세스는 관심이없다.
그저 상대에게 요청하고 이벤트 핸들러에 의해 알림이 오면 그때 처리하는 방식이다.
```

상대에게 이벤트가 발생했다고 **이벤트 핸들러(callback)**로 결과를 통지 받는 방식이다.



이벤트 통지 모델까지 오게된것은 결국 Netty가 **비동기식 이벤트 기반 네트워킹**을 지원한다.

그리고 그 안에 내부적으로 **논블로킹 소켓:** ServerSocketChannel, SocketChannel 들이 사용되기때문에



동기 비동기 블로킹 논블로킹, 이벤트 통지 같은 개념들을 기본적으로 알아야 한다.





### 총정리

- 블로킹/논블로킹, 동기/비동기 요약

  > 블로킹/논블로킹 = 요청받는 함수가 제어권(함수실행권)을 언제 넘겨주느냐의 차이

   

  **블로킹 :** 요청받는 함수가 작업을 모두 마치고 나서야 요청자에게 제어권을 넘겨줌 (그동안 요청자는 아무것도 하지않고 기다림)

  **논블로킹 :** 요청받은 함수가 요청자에게 제어권을 바로 넘겨줌 (그동안 요청자는 다른 일을 할 수 있음)

   

  > 동기/비동기 = 요청받은 함수가 작업을 완료했는지를 누가 체크하느냐의 차이

   

  **동기 :** 요청자가 요청받은 함수의 작업이 완료되었는지 계속 확인 (여러 함수들이 시간을 맞춰 실행됨)

  **비동기 :** 요청자는 요청후 신경X, 요청받은 함수가 작업을 마치면 알려줌 (함수들의 작업 시작/종료 시간이 맞지 않을수도)

  

  ## 블로킹/논블로킹, 동기/비동기 조합

  ![img](https://blog.kakaocdn.net/dn/bPPQIV/btq6VJFGShb/rRbDK1pgCsh9Qi9hNUeRyk/img.png)

  

   

  #### 블로킹 + 동기

  > 요청받은 함수의 작업이 끝나야 제어권 돌려받음 + 요청자는 결과가 나올때까지 계속 확인

   

  선배 : 이것좀 부탁해요~

  나 : 네 바로 끝나니까 기다려주세요

  선배 : (아무것도 안하고 기다림, 언제끝나는지 궁)

  나 : (타닥타닥..)

  선배 : (지켜보는중)

  선배 : 오 끝났네요!

  ####  

  #### 블로킹 + 비동기

  > 요청받은 함수의 작업이 끝나야 제어권 돌려받음 + 결과는 요청받은 함수가 알려줌

   

  선배 : 이것좀 부탁해요~

  나 : 네 바로 끝나니까 기다려주세요

  선배 : (아무것도 안하고 기다림, 언제끝나는지 관심없음)

  나 : (타닥타닥..)

  나 : 끝났어요!

  ##  

  #### 논블로킹 + 동기

  > 제어권은 바로 돌려줌 + 요청자는 결과가 나올때까지 계속 확인

   

  선배 : 이것좀 부탁해요~

  나 : 넵 (타닥타닥..)

  선배 : (할거 하다가) 다하셨나요?

  나 : 잠시만요

  선배 : (할거 하다가) 다하셨나요?

  나 : 네 여기요~

  ####  

  #### 논블로킹 + 비동기

  > 제어권은 바로 돌려줌 + 결과는 요청받은 함수가 알아서 알려줌

   

  선배 : 이것좀 부탁해요~

  나 : 넵 다하고 말씀드릴게요! (타닥타닥..)

  선배 : (할일 하는 중)

  나 : 끝났어요 여기요!

  

  



출처

https://slowdev.tistory.com/14

https://joooing.tistory.com/entry/

https://ju3un.github.io/network-basic-2/

