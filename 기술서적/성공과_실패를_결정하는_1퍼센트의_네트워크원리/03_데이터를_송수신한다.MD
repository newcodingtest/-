## 04. 데이터를 송수신 한다.

#### 프로토콜 스텍에 HTTP 리퀘스트 메시지를 넘긴다.

- TCP Connect가 되면 어플리케이션에게 **제어**가 돌아오고 데이터 송수신 동작에 들어간다

- 어플리케이션이 **write을 호출**하여 송신 데이터를 **프로토콜 스택**에 건네준다.
- 프로토콜 스텍은 받은 데이터의 내용을 모른다. 단지 송신 데이터의 길이만큼 데이터가 1바이트씩 나열되있다고만 인식하고 있다.
- 프로토콜 스텍은 받은 데이터를 송신용 버퍼 메모리에 저장하고, 어플리케이션이 데이터를 건네주기를 기다린다.
- 한 번의 송신 의뢰에서 건네주는 데이터의 길이는 어플리케이션 사정에 따라 달라지므로 프로토콜 스텍이 제어할 수 없다
- 어느 정도까지 저장한 후 **송신 동작**을 할지는 OS 버전에 따라 달라지지만 2가지 판단요소 중 하나인 **MTU** 라는 매개변수를 바탕으로 판단한다.
- MTU가 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이이다.

​	

| preamble / 스타트 프레임 딜리미터 | MAC 헤더 | IP 헤더 | TCP 헤더 | 데이터 | FCS  |
| --------------------------------- | -------- | ------- | -------- | ------ | ---- |

- MTU(Maximun Transmission Unit): IP헤더 ~ 데이터(이더넷에서는 1,500 바이트)
- MSS(Maximun Segment Size): 데이터



- 또다른 판단요소는 **타이밍**, 어플리케이션의 송신 속도가 느려져서 **MSS**에 가깝게 데이터를 저장하는 속도가 **지연**되어 버퍼에 데이터가 모이지 않아도 **프로토콜 스텍**은 내부의 타이머로 인해서 일정 시간 이상 경과시, 패킷을 송신한다.
- MTU, 타이밍 두가지 요소중 MTU 중시하면 **네트워크 이용 효율**이 높아지지만, 버퍼에 머무는 시간만큼 **송신 동작이 지연**될 우려가 있다.
- 타이밍을 중시하면 **지연**은 적어지나, 네트워크 이용 효율이 떨어지므로 양자를 잘 절충해야한다.
- 그러나 TCP 프로토콜 사양에는 절충에 관한 규정이 없고 어떻게 할지는 프로토콜 스텍 개발자에 맞겨지며, OS 종류/버전에 따라 동작이 달라진다.
- 프로토콜 스텍에만 맞기면 좋지 않은 일이 생길수 있으므로, 어플리케이션에서 송신 타이밍을 제어하는것을 보통 옵션으로 제공한다.(ex. 버퍼에 머물지 않고 송신)



#### 데이터가 클 때는 분할하여 보낸다

- 블로그 게시글 같은 긴 HTTP Request를 보낼때, 만약 한개의 패킷에 모두 담기지 않는다면 송신 버퍼에 저장된 데이터는 MSS 를 초과하므로 MSS 크기에 맞게 분할하고 분할한 조각을 한 개씩 패킷에 넣어서 분할 송신한다.



#### ACK 번호응 사용하여 패킷이 도착했는지 확인한다.

- 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당하는지 세어두고  이 값을 TCP 헤더에 기록한다. 이 값을 **시퀀스 번호** 라고한다.
- 패킷 전체 길이에서 헤더 길이를 빼면 데이터 크기를 계산할 수 있으므로 수신측은 이 2가지 방법으로 송신한 데이터가 몇 번째 바이트부터 시작되는 몇 바이트 분의 것인지 알 수 있다.
- 위 방식으로 수신측에서 패킷이 **누락**되었는지 확인할 수 있다. 몇번째 바이트까지 수신했는지 TCP 헤더의 **ACK** 번호에 기록하여 송신측에 알려준다.
- **ACK 번호**로 되돌려주는 동작을 수신 확인 응답 이라고 부르며, 송신측은 수신측의 **ACK 번호**를 통해 수신측이 어디까지 수신했는지 파악한다.
- TCP 는 상대방이 데이터를 수신한 것을 확인할 때까지 송신한 패킷을 **송신용 버퍼 메모리에  보관**해두며, 송신한 데이터에 대응하는 **ACK 번호**가 수신측으로부터 돌아오지 않으면 패킷을 **재전송**한다.(이 때문에 오류 검출/회복 처리 가능)
- LAN 어뎁터, 버퍼, 라우터 는 TCP의 **오류 검출** 기능으로 인해 회복 조치를 하지 않는다. 단, 도중의 케이블 분리, 서버 다운 등의 이유로 TCP 재전송해도 ACK 번호가 지속적으로 않오면 데이터 송신 동작을 종료하고 어플리케이션에게 오류를 통지한다.



#### 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.

- ACK 번호가 돌아오는 것을 기다리는 대기 시간을 **타임아웃** 값이라고 한다.
- 네트워크가 혼잡하면 **ACK 번호**가 돌아오는 것도 지연되므로 이것을 예측하여 대기 시간을 어느정도 길게 설정해야 한다.
- **ACK 번호**가 돌아오지 않으면 패킷을 재전송하게 되는데 보통 돌아오지 않는 원인은 **네트워크 혼잡**인 경우가 많은데 재전송 패킷으로 인해서 혼잡을 더욱 악화시킬 수 있다.
- **대기 시간**을 너무 길게하면 패킷 재전송 동작이 지연되어 **속도 저하의 원인**이 된다.
- 서버 거리에 따라서 **ACK 번호**의 돌아오는 시간도 달라지기 때문에 일정한 값으로 설정하기 힘들다. 그레서 TCP는 **대기 시간을 동적으로 변경하는 방법**을 취한다.
- **ACK 번호**가 돌아오는 시간을 기준으로 대기 시간을 판단하며, 데이터 송신 동작을 실행하고 있을때 항상 **ACK 번호**가 돌아오는 시간을 **계측**한다. 해당 시간보다 지연되면 바로 대기 시간도 **동적**으로 늘리며, 빠르게 오면 대기 시간을 짧게 설정한다.



#### 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.

- 한개의 패킷을 보내고 ACK 번호를 기다리는 것(**핑퐁**)은 비효율적인 방법이기 때문에 윈도우 제어 방식을 사용한다.
- 윈도우 제어는 ACK 번호를 기다리지 않고 **복수의 패킷**을 보내는 방법이다. 
- **핑퐁 방식**은 수신측의 능력을 초과하여 패킷을 보내지 않지만, 윈도우 제어는 **초과**하여 패킷을 보내는 사태가 일어날 수도 있다.

![img](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fccdb8b1d-624a-4326-ae30-e48f0b895495%2Fimg1.daumcdn.png&blockId=7fff3cfb-181c-492d-b7ac-5d5814bd6f40)

(그림출처: https://80000coding.oopy.io/875cb26a-017f-43d2-a0ab-58915fd21686)

- 초과 패킷 송신 사태를 방지하고자 먼저 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고. 송신측은 이를 통해 송신 양을 제어하여 송신하는 것이 **윈도우 제어 방식**의 개념이다,
- 수신측은 수신 버퍼에 데이터를 임시 보관하고, 수신 처리가 끝나고 수신 버퍼에 공간이 생기면 수신할 수 있는 데이터 양을 늘리므로 **TCP 헤더의 윈도우 필드**로 송신 측에 알린다. 이를 통해 수신측의 능력을 초과하여 데이터를 보내는 일이 없어진다,



#### ACK 번호와 윈도우를 합승한다.

- 송/수신 동작의 효율성을 높이기 위해서는 **ACK 번호와 윈도우 통지 타이밍**을 고려해야 한다.
- **윈도우 통지 동작**은 수신측 수신 버퍼에서 데이터를 추출하여 어플리케이션에 건네주었을 때 동작한다. 언제 동작이 일어날지에 대해서는 송신측은 알 수 없다.
- 때문에 수신측에서 어플리케이션에 데이터를 건네주고 수신 버퍼의 **빈 영역**이 늘어났을 때 이 때가 **윈도우 통지 타이밍**이다.
- **ACK 번호**는 수신측에서 데이터를 수신했을 때 내용을 조사하여 **정상 수신을 확인할 수 있는 경우**에만 송신측에 보낸다.
- 본래의 개념대로라면, 데이터가 수신측에 도착하여 수신 동작이 정상적으로 완료됬을때 **ACK 번호**를 송신측에 통지하고, 잠시 후 데이터를 어플리케이션에 건네주었을 때 **윈도우**를 송신측에 통지하는 상태가 된다. 다시 정리하면 **ACK 번호 통지와 윈도우 통지**의 패킷이 하나씩 따로 송신측에 보내진다. 그러나 이 방식은 수신측에서 송신측에 보내는 패킷이 많아져서 **효율성이 저하**된다.
- 때문에 수신측은 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다리고, 기다리는 사이 다음 통지 동작이 일어나면 양쪽을 묶어서 한 개의 패킷으로 묶어서 보낸다
- 예를 들어 **ACK 번호**의 송신을 대조할 때 **윈도우 통지**가 일어나면 ACK 번호와 윈도우를 **한 개의 패킷으로 합승**시켜서 통지하여 **패킷의 수를 줄일 수 있다.**
- 복수의 **ACK 번호** 통지가 연속해서 일어나도 최후의 것만 통지하고 도중의 것은 생략해도 상관 없고 마찬가지로 **패킷의 수를 줄일 수 있다.**
- **윈도우 통지**도 마찬가리고 윈도우 통지가 계속되는 것은 어플리케이션에 데이터를 건네주는 동작이 연속해서 일어나고, 수신 버퍼의 빈 영역이 점점 늘어나고 있는 상황이라고 생각할 수 있다. 이 경우에도 마찬가지로 도중의 것을 생략하고 최후의 것만 통지한다.



#### HTTP 응답 메세지를 수신한다.

- 브라우저는 Request 메시지를 송신해 달라고 의뢰하고, 이것이 끝나면 서버로 돌아오는 응답 메시지를 받기 위해 read 프로그램을 호출한다.
- read를 경유하여 프로토콜 스텍에 제어가 넘어가고, 프로토콜 스텍은 수신 버퍼에서 수신 데이터를 추출하여 어플리케이션에 건네준다. 이때 Request 메시지의 송신을 완료하고 나서 얼마 안된 시점이라면 아직 응답 메시지가 돌아오지 않았을 것이다. 이 때는 프로토콜 스텍은 의뢰받은 작업, 즉 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네주는 작업을 잠시 보류한다.
- 서버에 응답 메시지의 패킷이 도착했을 때 그것을 수신하여 어플리케이션에 건네주는 작업을 재개한다.
- 프로토콜 스텍은 **수신한 데이터 조각과 TCP 헤더의 내용을 조사**하여 도중에 데이터가 누락되었는지 검사하고 문제가 없으면 ACK 번호를 반송한다.
- 그리고 데이터 조각을 수신 버퍼에 일시 보관하고, 조각을 연결히고 어플리케이션이 지정한 메모리 영역에 옮겨준 기록한 후 어플리케이션에게 제어를 돌려주고 나서 타이밍을 가늠하여 윈도우를 송신측에 통지한다.

