## 04. 서버에서 연결을 끊어 소켓을 말소한다.

프로토콜 스텍은 서버든 클라이언트든 어느 쪽에서 먼저 연결 끊기 단계에 들어가도 좋게 만들어져 있다.

**여기서는 서버가 연결은 끊는 전제하에 글을 작성한다.**



#### 1. 데이터 보내기를 완료했을 때 연결을 끊는다.

- 서버측의 어플리케이션에서 Socket 라이브러리의 **close를 호출**한다.
- 서버측의 프로토콜 스텍이 TCP 헤더를 만들고, 연결끊기를 나타내는 정보를 설정한다.
- 구체적으론, 컨트롤 비트의 **FIN 비트에 1**을 설정하고, IP 담당 부분에 의뢰하여 클라이언트에 송신해 달라고 한다.
- 클라이언트측에서 서버가 전송한 **FIN 1**의 TCP 헤더가 도착하면 클라이언트의 **프로토콜 스텍**은 자신의 소켓에게 서버측의 연결 끊기 동작에 들어갔다는 것을 기록한다,
- 그 후 FIN을 1로 설정한 패킷을 잘 받았다고 서버측에게 ACK 번호를 전송한다.
- 잠시 후 클라이언트 어플리케이션이 **read**를 호출해서 데이터를 요청할때, 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신완료 했다는 사실을 클라이언트 어플리케이션(브라우저) 에게 알린다.
- **웹의 동작**은 서버가 응답을 반송하면 끝나도록 **규칙**이 정해져 있기 때문에 서버측에서 보낸 데이터를 전수 수신 완료하면 클라이언트도 **종료**한다.
- 클라이언트 어플리케이션도 Socket 라이브러리의 **close를 호출** 하여 데이터 송수신 동작을 끝내고, 클라이언트의 프로토콜 스텍은 **FIN 비트에 1**을 설정한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 서버에 전송한 뒤, 서버에서 ACK 번호가 돌아오면 서버와의 대화가 종료된다.

<BR>



#### 2. 소켓을 말소한다.9

- 오동작 방지를 이유로 소켓은 바로 말소되지 않고 잠시 기다린 후 소켓을 말소한다.
- 클라이언트가 서버와 연결을 끊기위헤 FIN을 하는 과정에서 클라이언트의 소켓이 원인 모를 이유로 인해 말소되어 있다는 가정한다.
- 클라이언트는 FIN을 전송하고 서버로 부터 ACK를 수신받은 뒤 소켓이 말소된다. 서버는 클라이언트로 FIN을 전송했는데 ACK가 수신되지 않으므로 지속적으로 FIN을 전송할 것이다.
- 소켓을 말소하면 기록되어 있던 제어정보 그리고 소켓에 할당되어 있던 포트 번호도 알 수 없게 된다.
- 이 시점에 새로운 어플리케이션이 소켓을 작성하면 새 소켓에 같은 포토 번호가 할당될 가능성이 있다,
- 이런경우 서버는 아직 ACK를 수신받지 못했기 때문에 FIN을 전송할 것이고, 같은 포트 번호를 가진 새로운 어플리케이션은 서버로 부터 수신된 FIN 정보로 인해서, 소켓 연결을 하자마자 연결 끊기 동작에 들어가버린다.
- 위 같은 오동작을 막기 위해서 소켓을 즉시 말소하지 않고 잠시 기다리는 이유이다.
- 소켓이 기다리는 시간 등 **명확한 규정은 없지만** **일반적으로 보통 몇 분 정도** 가디라고 나서 소켓을 말소한다,

<BR>



#### 3. 데이터 송수신 동작을 정리

![image-20241208002709171](https://github.com/user-attachments/assets/723d1b1b-6e2b-4164-a576-26cb7e9b08a9)
