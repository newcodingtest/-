
# 삽입정렬

## 원리

삽입 정렬의 전체적인 과정은 이렇다. (오름차순을 기준으로 설명)

**1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다. (첫 번째 타겟은 두 번째 원소부터 시작한다.)**

**2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.**

**3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.** 

![img](https://blog.kakaocdn.net/dna/KRty3/btqOKXNAGUh/AAAAAAAAAAAAAAAAAAAAAOGmFao3hg6ToNcmGJyR7arhdCuHrYgmvu2Xw8RjuUxF/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1759244399&allow_ip=&allow_referer=&signature=8woC4TbYc93hst9zQjpwyCCrF0M%3D)


<br>

## 코드

**최선 시간복잡도: O(n)**

**최악 시간복잡도: O(n²)**

```java
   
    public static void 삽입정렬(int[] arr){
        for (int i=1; i<arr.length; i++){
           int nowKey = arr[i];
           int preIdx = i-1;

           while(preIdx>0 && arr[preIdx]>nowKey){
               arr[preIdx+1] = arr[preIdx];
               preIdx--;
           }

           arr[preIdx+1]=nowKey;
        }
    }
```

<br>

## 궁금증

### 🔹 왜 `arr[preIdx + 1]`인가?

- `while` 루프에서 `j`를 하나 줄일 때마다 **값을 오른쪽으로 한 칸씩 밀기** 때문에, 마지막으로 멈췄을 때 `j`는 `key`가 들어갈 자리보다 **하나 앞**을 가리키고 있습니다.
- 그래서 `key`는 `j + 1` 위치에 넣어야 정확히 들어갑니다.

<br>



### **장점**

1. 추가적인 메모리 소비가 작다.
2. 거의 정렬 된 경우 매우 효율적이다. 즉, 최선의 경우 O(N)의 시간복잡도를 갖는다.
3. 안장정렬이 가능하다.



### **단점**

1. 역순에 가까울 수록 매우 비효율적이다. 즉, 최악의 경우 O(N2)의 시간 복잡도를 갖는다.
2. 데이터의 상태에 따라서 성능 편차가 매우 크다. 

<br><br><br>









출처:

https://st-lab.tistory.com/179
