### 실시간 모니터링 사이트



### 방법

### **1.HTTP 실시간 통신 방식들**

#### **polling**

![image](https://user-images.githubusercontent.com/57785267/162889217-2d475464-0aa5-4fb0-892b-a769c09a40af.png)

브라우저가 일정 주기마다 서버에 http 요청을 보내는 방식(구현이 단순)

실시간 데이터의 업데이트 주기는 예측 불가하므로 불필요한 요청에 따른 서버 및 네트워크의 부하가 늘어남

실시간 야구 문자 중계 같이 5~10초 주기로 계속 업데이트 시키는 방식
<br>

- 단점

  시간 주기를 어떻게 설정 하느냐에 따라 서버의 부하성 또는 실시간성이 떨어지는 관계를 갖는다.
  <br>

**BEST**

실시간성이 조금 떨어져도 되고 시간을 늘려 여러 클라이언트와 통신할 때 사용

ex)페북의 친구 리스트의 온라인 상태확인(1분주기)

<br>
<br>



### **long polling**

![image](https://user-images.githubusercontent.com/57785267/162889244-54948b25-fcf1-4794-b3a1-5fb69818282b.png)

polling의 서버 부하를 줄이면서 실시간성을 높이기 위한 방식

http 요청시 서버는 해당 연결을 바로 해제하지 않고 **일정시간 대기**시킨다. 대기 시간중 업데이트(변경 이벤트)가 일어났으면 바로 클라에게 응답을 전송하고 전달 메시지를 처리한다. 응답을 받은 클라는 바로 서버에 다시 요청을 보낸다

브라우저의 요청이 있어도 요청한 서버의 요청한 서버의 데이터 변경이 없으면 보내지 않는다.

응답이 와서 연결이 끊기면 클라이언트가 서버에 다시 요청한다.
<br>

- **단점**

  여러 클라이언트에서 잦은 변경이 일어나면 서버 부담이 큼

 수백 수천대의 클라와 연결된 채팅 서버에서 한명이 채팅을 쓰면 데이터가 변경되어 서버는 변경된 데이터를 연결된 수많은 클라에게 동시에 response를 보내고 다시 모든 클라에게 request를 받으므로 순간적으로 큐가 쌓여 서버에 부담을 줄 수 있다.
 <br>

**BEST**

실시간성이 필요한 적은 수의 클라이언트와 연결되어 있는 경우에 사용

**ex)**

웹 1:1채팅, 10명 이하의 상대와 채팅하는 경우


<br>
<br>




### Streaming

![image](https://user-images.githubusercontent.com/57785267/162889340-2471ee0b-cadd-432a-9d2d-dcff651c1bd6.png)

long polling의 연결 구축에 대한 부하를 해결하는 방식

요청에 대한 응답을 완료하지 않은 상태에서 데이터를 계속 내려받는 방식

응답을 받더라도 연결을 끊고 다시 request 요청을 보내는 과정 없이 계속 응답을 받아 처리

서버는 무한정 혹은 일정 시간동안 요청을 대기시키고 chuncked 메시지를 이용하여 응답시 연결을 계속 유지한다.
<br>

- 단점

  클라이언트에서 서버로 데이터를 보내는게 힘들다

  실시간 양방향 통신이 아닌 실시간 단방향 통신이 주로 이뤄짐

  연결이 길어질수록 연결의 유효성 부담이 발생(대게 특정 시간을 주기로 연결을 재설정하도록 구현)
  
<br>
  
 chuncked 메시지

```
- 서버에서 클라이언트가 요청한 응답이 매우 큰 경우 이를 chunk단위로 나누어서 보내는 것

- 응답에 대한 데이터 크기를 알 필요가 없음

- 동적으로 생성되는 자원에 대한 전송에 유리 (스트림 등)

- "Content-Length"는 body 사이즈를 정하는 Header임. Context-Length 대신 "Transfer-Encoding : chunked'가 온다면 chunk단위로 데이터를 전송 하겠다는 뜻
```

<br>

**BEST**
- 동영상 스트리밍

#### 정리

**polling**: 일정 주기마다 서버에 계속 요청(이벤트가 없어도 요청 -> 서버, 클라 부담)

**long polling**: 서버에 요청을 보내놓고 서버에서 이벤트가 발생하면 응답, 다시 연결(이벤트 발생시 연결된 모든 클라에게 동시 응답을 보내고 연결을 끊음, 새로운 요청을 받는다, -> 서버 부담)

**Streaming**: 서버에 연결 요청을 보내고 계속 응답 데이터를 다운 받는다.

​                    서버가 이벤트 발생시 응답을 보낸다

<br>
<br>

###  **2.웹소켓**

웹에서 하나의 TCP 연결을 통해 양방향 통신을 제어하는 프로토콜

실시간 서비스를 구현하기에 적합

HTTP의 반이중(Half-Duplex) 방식이 아닌 전이중(Full-Duplex) 방식임

```
Half-Duplex
:양방향 통신을 하지만 송수신을 동시에 할 수 없고, 무전기 방식처럼 해야함
Full-Duplex
:동시에 송수신을 하며, 양방향 통신이 가능
```


#### **원리**
![image](https://user-images.githubusercontent.com/57785267/162889323-100823e4-4182-44d9-90c2-1cb8f63b43bd.png)

- 웹소켓 연결을 위해 http 통신을 한다
- handshake 과정이 성공적으로 이뤄지면   **http ->웹 소켓 프로토콜**로 변경하는 스위칭이 이뤄짐
- 웹소켓을 위한 소켓이 생성되고 해당 소켓로 전이중 통신을 한다




#### 특징

- 최초 접속이 http를 이용한 handshaking으로 이뤄진다.

- TCP Socket은 바이트 스트림을 이용하지만, 웹 소켓은 UTF-8의 텍스트와 바이너리 둘다 보낼 수 있다

- 텍스트의 경우 시작과 끝에 0x00과 0xFF를 붙여서 구분한다

- Statefull

  서버와 클라이언트가 한번 연결되면 계속 같은 라인을 사용해 통신하므로 HTTP 사용시 필요없이 발생되는 HTTP와 TCP 연결 트래픽을 피할 수 있다

  웹 소켓은 최초접속을 제외하면 헤더 정보를 보내지 않지만, HTTP 프로토콜은 요청을 할 때마다 헤더정보를 보내게 되므로 네트워크 비용에서 이득이다.

- HTTP 요청을 그대로 사용하므로 80, 443포트를 그대로 사용할 수 있고, HTTP의 구격인 CORS적용, 인증 등을 기존과 동일하게 이용할 수 있다

<br>

#### **단점**
 - 구현이 복잡하다<br>
   웹 소켓은 http와 달리 StateFul protocol이기 때문에 서버와 클라이언트 간의 연결을 항상 유지해야 하며, 비정상적으로 연결이 끊어졌을때 적절히 대응해야한다
   이는 기존의 http 사용과 비교했을때 복잡성을 가중시키는 요인이 될 수 있다.\
   
 - 서버와 클라이언트간의 소켓 연결을 유지하는 것 자체가 비용이 든다<br>
   특히 트래픽 양이 많은 서버같은 경우 CPU에 큰 부담이 될 수 있다.

 - 오래된 버전의 웹 브라우저에서는 지원하지 않는다.(ie10 이상 버전부터 )



출처: https://ws-pace.tistory.com/104
